# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title jrSiCKLSNMF
#' @description Perform joint non-negative matrix factorization (NMF) across multiple views of single cell data.
#' Users can choose to use the Poisson Kullback-Leibler divergence or the Frobenius norm.
#' Users can also set graph regularization constraints on W and sparsity constraints on H.
#' This function updates WL and H.
#' @name jrSiCKLSNMF
#' @param datamatL An R list where each entry contains a sparse X matrix corresponding to a single cell data view
#' Each X is m^v features by n cells. Features can differ across matrices; however, n must be the same for
#' each view. All data are measured on the same set of cells
#' @param WL An R list containing initialized values for the W within each view. These are passed by reference
#' @param H A matrix containing initialized values for the shared H
#' @param AL An R list containing all of the graph laplacians in sparse format
#' @param lambdaWL A list of each lambdaW for each view
#' @param lambdaH A double containing the desired value for H
#' @param diffFunc A string indicating what type of divergence to use. It is Poisson Kulback Leibler by default
#' @param Hconstraint A string that indicates whether you want to force constraints on the rows of H. Enter "None" for
#' no constraints, enter "L1Norm" to ensure all rows of H sum to 1, and "L2Norm" to ensure that the the
#' L2 norm of each row of H equals 1. Please note that jrSiCKLSNMF stores H as the transpose of H, so the code
#' will perform regularization on the columns of the transpose of H.
#' @param differr A double containing the tolerance
#' @param rounds A double containing the number of rounds
#' @param display_progress A boolean to indicate whether the user wants to display the progress
#' @returns An R list containing values for the objective function.
#' @export
jrSiCKLSNMF <- function(datamatL, WL, H, AL, lambdaWL, lambdaH = 0.0, diffFunc = "klp", Hconstraint = "L2Norm", differr = 1e-6, rounds = 10000, display_progress = TRUE) {
    .Call(`_jrSiCKLSNMF_jrSiCKLSNMF`, datamatL, WL, H, AL, lambdaWL, lambdaH, diffFunc, Hconstraint, differr, rounds, display_progress)
}

